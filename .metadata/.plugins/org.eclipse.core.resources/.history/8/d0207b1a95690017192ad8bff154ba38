/*
 * SeperateObjects.cpp
 *
 *  Created on: 9 Jul 2017
 *      Author: sheun
 */

#include "SeperateObjects.h"
//#include <vector>
//#include <stdlib.h>

//using namespace std;
//RNG rng(12345);
SeperateObjects::SeperateObjects() {


}

SeperateObjects::~SeperateObjects() {

}

Mat1b SeperateObjects::BoundBox(Mat1b Binary, Mat3b origanal_image)
{
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;
	//find contours

	findContours(Binary, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0,0));

	 /// Get the moments
	  vector<Moments> mu(contours.size() );
	  for( int i = 0; i < contours.size(); i++ )
	     { mu[i] = moments( contours[i], false ); }

	  ///  Get the mass centers:
	    vector<Point2f> mc( contours.size() );
	    for( int i = 0; i < contours.size(); i++ )
	       { mc[i] = Point2f( mu[i].m10/mu[i].m00 , mu[i].m01/mu[i].m00 ); }

	//Approximate contours to polygons + get bounding rects
	vector<vector<Point> > contours_poly(contours.size());
	vector<Rect> boundRect(contours.size());
	//get image coordinate;
	vector<int>x_coordinate( contours.size() );
	vector<int>y_coordinate( contours.size() );
	vector<Mat> subregions;
	for(int i = 0; i < contours.size(); i++)
	{
		approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
		boundRect[i] = boundingRect(Mat(contours_poly[i]));
		boundRect.push_back(boundingRect(Mat(contours_poly[i])));
		x_coordinate[i] = boundRect[i].x;
		y_coordinate[i] = boundRect[i].y;
		//cout<<x_coordinate[i]<<endl;

        // Get bounding box for contour
        //Rect roi = boundingRect(contours[i]); // This is a OpenCV function

        // Create a mask for each contour to mask out that region from image.
        Mat mask = Mat::zeros(origanal_image.size(), CV_8UC1);
       // drawContours(mask, contours, i, Scalar(255), CV_FILLED); // This is a OpenCV function

        // At this point, mask has value of 255 for pixels within the contour and value of 0 for those not in contour.

        // Extract region using mask for region
        Mat contourRegion;
        Mat imageROI;
        origanal_image.copyTo(imageROI, mask); // 'image' is the image you used to compute the contours.
        contourRegion = imageROI(boundRect[i]);
        // Mat maskROI = mask(roi); // Save this if you want a mask for pixels within the contour in contourRegion.

        // Store contourRegion. contourRegion is a rectangular image the size of the bounding rect for the contour
        // BUT only pixels within the contour is visible. All other pixels are set to (0,0,0).
        subregions.push_back(contourRegion);
        imshow("one_object_test", subregions[i]);

	}


	//Draw polygon contour + bounding rects


	Mat drawing = Mat::zeros(Binary.size(), CV_8UC3);
	for (int i = 0; i<contours.size(); i++)
	{
		printf(" * Contour[%d] - Area (M_00) = %.2f - Area OpenCV: %.2f - Length: %.2f \n", i, mu[i].m00, contourArea(contours[i]), arcLength( contours[i], true ) );
		//Scalar color = Scalar(rng.uniform(0,255), rng.uniform(0,255), rng.uniform(0,255));
		Scalar color( rand()&255, rand()&255, rand()&255 );
		//Scalar color( 0, 0, 255);
		//drawContours(Binary, contours_poly, i, color, 1,8, vector<Vec4i>(), 0, Point());
		rectangle (Binary, boundRect[i].tl(), boundRect[i].br(), color, 2,8,0);
	}



	return Binary;
}

